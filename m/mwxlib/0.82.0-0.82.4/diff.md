# Comparing `tmp/mwxlib-0.82.0-py3-none-any.whl.zip` & `tmp/mwxlib-0.82.4-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,24 @@
-Zip file size: 161376 bytes, number of entries: 22
--rw-rw-rw-  2.0 fat     2521 b- defN 23-Mar-25 12:55 mwx/__init__.py
--rw-rw-rw-  2.0 fat    43241 b- defN 23-Mar-27 04:44 mwx/controls.py
--rw-rw-rw-  2.0 fat    72432 b- defN 23-Apr-07 01:41 mwx/framework.py
--rw-rw-rw-  2.0 fat    69528 b- defN 23-Apr-07 01:41 mwx/graphman.py
+Zip file size: 161411 bytes, number of entries: 22
+-rw-rw-rw-  2.0 fat     2521 b- defN 23-Apr-27 09:45 mwx/__init__.py
+-rw-rw-rw-  2.0 fat    43241 b- defN 23-Apr-27 09:45 mwx/controls.py
+-rw-rw-rw-  2.0 fat    72345 b- defN 23-May-01 05:02 mwx/framework.py
+-rw-rw-rw-  2.0 fat    69266 b- defN 23-May-01 05:02 mwx/graphman.py
 -rw-rw-rw-  2.0 fat    46248 b- defN 23-Feb-21 08:49 mwx/images.py
--rw-rw-rw-  2.0 fat    36004 b- defN 23-Mar-25 12:55 mwx/matplot2.py
--rw-rw-rw-  2.0 fat    67727 b- defN 23-Mar-25 13:34 mwx/matplot2g.py
--rw-rw-rw-  2.0 fat    27606 b- defN 23-Mar-25 12:55 mwx/matplot2lg.py
+-rw-rw-rw-  2.0 fat    36004 b- defN 23-Apr-27 09:45 mwx/matplot2.py
+-rw-rw-rw-  2.0 fat    67727 b- defN 23-Apr-27 09:45 mwx/matplot2g.py
+-rw-rw-rw-  2.0 fat    27606 b- defN 23-Apr-27 09:45 mwx/matplot2lg.py
 -rw-rw-rw-  2.0 fat     6878 b- defN 23-Feb-21 08:50 mwx/mgplt.py
--rw-rw-rw-  2.0 fat   137961 b- defN 23-Apr-07 03:19 mwx/nutshell.py
--rw-rw-rw-  2.0 fat    36740 b- defN 23-Apr-05 02:34 mwx/utilus.py
--rw-rw-rw-  2.0 fat    11187 b- defN 23-Apr-07 01:41 mwx/wxmon.py
--rw-rw-rw-  2.0 fat    19793 b- defN 23-Apr-05 02:34 mwx/wxpdb.py
+-rw-rw-rw-  2.0 fat   138522 b- defN 23-Apr-29 15:51 mwx/nutshell.py
+-rw-rw-rw-  2.0 fat    36923 b- defN 23-Apr-29 15:40 mwx/utilus.py
+-rw-rw-rw-  2.0 fat    11247 b- defN 23-Apr-29 16:20 mwx/wxmon.py
+-rw-rw-rw-  2.0 fat    19668 b- defN 23-Apr-28 08:56 mwx/wxpdb.py
 -rw-rw-rw-  2.0 fat     5246 b- defN 23-Mar-25 12:54 mwx/wxwil.py
--rw-rw-rw-  2.0 fat     7398 b- defN 23-Mar-27 10:09 mwx/wxwit.py
+-rw-rw-rw-  2.0 fat     7416 b- defN 23-Apr-29 16:25 mwx/wxwit.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Jan-23 14:06 mwx/py/__init__.py
--rw-rw-rw-  2.0 fat    16794 b- defN 23-Apr-05 02:34 mwx/py/filling.py
--rw-rw-rw-  2.0 fat     1091 b- defN 23-Apr-07 04:09 mwxlib-0.82.0.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     1893 b- defN 23-Apr-07 04:09 mwxlib-0.82.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Apr-07 04:09 mwxlib-0.82.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        4 b- defN 23-Apr-07 04:09 mwxlib-0.82.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     1609 b- defN 23-Apr-07 04:09 mwxlib-0.82.0.dist-info/RECORD
-22 files, 611993 bytes uncompressed, 158874 bytes compressed:  74.0%
+-rw-rw-rw-  2.0 fat    16794 b- defN 23-Apr-27 09:45 mwx/py/filling.py
+-rw-rw-rw-  2.0 fat     1091 b- defN 23-May-01 05:09 mwxlib-0.82.4.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1893 b- defN 23-May-01 05:09 mwxlib-0.82.4.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-May-01 05:09 mwxlib-0.82.4.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        4 b- defN 23-May-01 05:09 mwxlib-0.82.4.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1609 b- defN 23-May-01 05:09 mwxlib-0.82.4.dist-info/RECORD
+22 files, 612341 bytes uncompressed, 158909 bytes compressed:  74.0%
```

## zipnote {}

```diff
@@ -45,23 +45,23 @@
 
 Filename: mwx/py/__init__.py
 Comment: 
 
 Filename: mwx/py/filling.py
 Comment: 
 
-Filename: mwxlib-0.82.0.dist-info/LICENSE
+Filename: mwxlib-0.82.4.dist-info/LICENSE
 Comment: 
 
-Filename: mwxlib-0.82.0.dist-info/METADATA
+Filename: mwxlib-0.82.4.dist-info/METADATA
 Comment: 
 
-Filename: mwxlib-0.82.0.dist-info/WHEEL
+Filename: mwxlib-0.82.4.dist-info/WHEEL
 Comment: 
 
-Filename: mwxlib-0.82.0.dist-info/top_level.txt
+Filename: mwxlib-0.82.4.dist-info/top_level.txt
 Comment: 
 
-Filename: mwxlib-0.82.0.dist-info/RECORD
+Filename: mwxlib-0.82.4.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## mwx/framework.py

```diff
@@ -1,14 +1,14 @@
 #! python3
 # -*- coding: utf-8 -*-
 """mwxlib framework
 
 Author: Kazuya O'moto <komoto@jeol.co.jp>
 """
-__version__ = "0.82.0"
+__version__ = "0.82.4"
 __author__ = "Kazuya O'moto <komoto@jeol.co.jp>"
 
 from functools import wraps, partial
 from importlib import reload
 import traceback
 import builtins
 import datetime
@@ -953,23 +953,23 @@
         builtins.typename = typename
         builtins.reload = reload
         builtins.partial = partial
         builtins.p = print
         builtins.pp = pp
         builtins.mro = mro
         builtins.where = where
-        builtins.watch = watchit
         builtins.filling = filling
         builtins.profile = profile
         builtins.timeit = timeit
         builtins.info = self.info
         builtins.help = self.help
         builtins.dive = self.clone_shell
         builtins.load = self.load
         builtins.debug = self.debug
+        builtins.watch = self.watch
         builtins.highlight = self.highlight
         
         from .nutshell import Nautilus, EditorBook
         
         self.__shell = Nautilus(self,
                                 target or __import__("__main__"),
                                 style=(wx.CLIP_CHILDREN | wx.BORDER_NONE),
@@ -1192,25 +1192,24 @@
         """Save session to file."""
         try:
             scratch = self.Scratch.default_buffer
             if scratch and scratch.mtdelta is None:
                 scratch.SaveFile(self.SCRATCH_FILE)
             
             with open(self.SESSION_FILE, 'w', encoding='utf-8', newline='') as o:
-                o.write('\n'.join((
-                    "#! Session file (This file is generated automatically)",
-                    "self.SetSize({})".format(self.Size),
-                    "",
-                )))
+                o.write("#! Session file (This file is generated automatically)\n")
+                
                 for book in self.get_pages(type(self.Log)):
-                    for buffer in book.all_buffers:
-                        if buffer.mtdelta is not None:
-                            o.write("self._load_file({!r}, {!r}, {})\n".format(
-                                     book.Name, buffer.filename, buffer.markline+1))
+                    for buf in book.all_buffers:
+                        if buf.mtdelta is not None:
+                            o.write("self._load_file({!r}, {!r}, {})\n"
+                                    .format(book.Name, buf.filename, buf.markline+1))
                 o.write('\n'.join((
+                    "self.SetSize({})".format(self.Size),
+                    "self.SetPosition({})".format(self.Position),
                     "self.ghost.SetSelection({})".format(self.ghost.Selection),
                     "self.watcher.SetSelection({})".format(self.watcher.Selection),
                     "self._mgr.LoadPerspective({!r})".format(self._mgr.SavePerspective()),
                     "self.ghost.loadPerspective({!r})".format(self.ghost.savePerspective()),
                     "self.watcher.loadPerspective({!r})".format(self.watcher.savePerspective()),
                     ## "self._mgr.GetPane('ghost').FloatingPosition(self.Position)",
                     ## "self._mgr.GetPane('watcher').FloatingPosition(self.Position)",
@@ -1448,28 +1447,27 @@
             filename, ln = m.groups()
             lineno = int(ln)
         else:
             filename = obj
             lineno = 0
         book = next((x for x in self.get_pages(type(self.Log))
                              if x.find_buffer(filename)), self.Log)
-        try:
-            wnd = wx.Window.FindFocus() # original focus
-            self.popup_window(book, focus=focus)
-            return book.load_file(filename, lineno)
-        finally:
-            if wnd and not focus: # restore focus if needed
-                wnd.SetFocus()
+        self.popup_window(book, focus=focus)
+        return book.load_file(filename, lineno)
     
     def info(self, obj):
         self.rootshell.info(obj)
     
     def help(self, obj):
         self.rootshell.help(obj)
     
+    def watch(self, obj):
+        self.monitor.watch(obj)
+        self.popup_window(self.monitor)
+    
     def highlight(self, obj, *args, **kwargs):
         self.inspector.highlight(obj, *args, **kwargs)
     
     ## Note: history 変数に余計な文字列が入らないようにする
     @postcall
     def debug(self, obj, *args, **kwargs):
         if isinstance(obj, wx.Object) or obj is None:
@@ -1609,16 +1607,16 @@
     def on_monitor_end(self, widget):
         """Called when monitor unwatch."""
         self.inspector.set_colour(widget, 'black')
         self.message("Stopped monitoring {!r}.".format(widget))
     
     def on_title_window(self, obj):
         """Set title to the frame."""
-        self.SetTitle("Nautilus - {}".format(
-                      obj if isinstance(obj, str) else repr(obj)))
+        title = obj if isinstance(obj, str) else repr(obj)
+        self.SetTitle("Nautilus - {}".format(title))
     
     def add_log(self, text):
         """Add text to the logging buffer."""
         buf = self.Log.default_buffer or self.Log.new_buffer()
         with buf.off_readonly():
             buf.write(text)
         ## Logging text every step in case of crash.
```

## mwx/graphman.py

```diff
@@ -1566,28 +1566,24 @@
         try:
             frames = []
             frame = None
             for i, path in enumerate(paths):
                 f = os.path.basename(path)
                 self.statusbar("Loading {!r} ({} of {})...".format(f, i+1, len(paths)))
                 try:
-                    with warnings.catch_warnings():
-                        warnings.simplefilter("ignore", ResourceWarning)
-                        buf, info = self.read_buffer(path)
-                    
+                    buf, info = self.read_buffer(path)
                 except Image.UnidentifiedImageError:
                     retvals = self.handler('unknown_format', path)
                     if retvals and any(retvals):
                         continue
                     raise # no contexts or handlers
                 
-                frame = view.load(buf, f, show=0, # do not show while loading
-                                  pathname=path, **info)
+                ## Do not show while loading
+                frame = view.load(buf, f, show=0, pathname=path, **info)
                 frames.append(frame)
-                wx.GetApp().Yield()
                 
                 if isinstance(buf, TiffImageFile) and buf.n_frames > 1: # multi-page tiff
                     n = buf.n_frames
                     dg = int(np.log10(n)) + 1
                     fmt = "{{:0>{}}}-{}".format(dg, f) # zero padding for numerical sort
                     for j in range(1,n):
                         self.statusbar("Loading {!r} [{} of {} pages]...".format(f, j+1, n))
@@ -1657,17 +1653,17 @@
         try:
             name = os.path.basename(path)
             self.statusbar("Saving {!r}...".format(name))
             busy = wx.BusyInfo("One moment please, "
                                "now saving {!r}...".format(name))
             stack = [Image.fromarray(x.buffer.astype(int)) for x in frames]
             stack[0].save(path,
-                    save_all=True,
-                    compression="tiff_deflate", # cf. tiff_lzw
-                    append_images=stack[1:])
+                          save_all=True,
+                          compression="tiff_deflate", # cf. tiff_lzw
+                          append_images=stack[1:])
             
             self.statusbar("\b done.")
             return True
         except Exception as e:
             print("-", self.statusbar("\b failed."))
             wx.MessageBox(str(e), style=wx.ICON_ERROR)
         finally:
@@ -1699,21 +1695,17 @@
         
         ## Load the session in the shell.
         shell = self.shellframe.rootshell
         shell.locals.update(
             nan = np.nan,
             inf = np.inf,
         )
-        try:
-            shell.Freeze()
-            with open(f) as i:
-                shell.Execute(i.read())
-            self._mgr.Update()
-        finally:
-            shell.Thaw()
+        with open(f) as i:
+            shell.Execute(i.read())
+        self._mgr.Update()
         
         self.menubar.reset()
         dirname_ = os.path.dirname(f)
         if dirname_:
             os.chdir(dirname_)
         self.statusbar("\b done.")
     
@@ -1733,19 +1725,18 @@
         if not f:
             return self.save_session_as()
         
         self.statusbar("Saving session to {!r}...".format(f))
         
         with open(f, 'w') as o,\
           np.printoptions(threshold=np.inf): # printing all(inf) elements
-            o.write('\n'.join((
-                "#! Session file (This file is generated automatically)",
-                "self.SetSize({})".format(self.Size),
-                ""
-            )))
+            o.write("#! Session file (This file is generated automatically)\n")
+            o.write("self.SetSize({})\n".format(self.Size))
+            o.write("self.SetPosition({})\n".format(self.Position))
+            
             for name, module in self.plugins.items():
                 plug = self.get_plug(name)
                 path = os.path.abspath(module.__file__)
                 basename = os.path.basename(path)
                 if basename == "__init__.py": # is module package?
                     path = path[:-12]
                 session = {}
```

## mwx/nutshell.py

```diff
@@ -136,30 +136,30 @@
                        'motion' : (100, self.on_linesel_motion, skip),
                  'capture_lost' : (0, self.on_linesel_end, skip),
              'Lbutton released' : (0, self.on_linesel_end, skip),
             },
         })
         
         def click_fork(v, click):
-            if self._margin is not None:
-                v.Margin = self._margin # Add info to event object. OK ??
+            if self.__margin is not None:
+                v.Margin = self.__margin # Add info to event object. OK ??
                 self.handler(f"margin_{click}", v)
             v.Skip()
-        self._margin = None
+        self.__margin = None
         
         def on_motion(v):
             self._window_handler('motion', v)
             x, y = v.Position
             w = 0
             for m in range(4):
                 w += self.GetMarginWidth(m)
                 if x < w:
-                    self._margin = m # current margin under mouse
+                    self.__margin = m # current margin under mouse
                     return
-            self._margin = None
+            self.__margin = None
             v.Skip()
         self.Bind(wx.EVT_MOTION, on_motion)
         
         self.Bind(wx.EVT_MOUSE_CAPTURE_LOST,
                   lambda v: self._window_handler('capture_lost', v))
         
         ## cf. wx.py.editwindow.EditWindow.OnUpdateUI => Check for brace matching
@@ -783,34 +783,34 @@
         self.CaptureMouse()
         lc = self.LineFromPosition(p)
         if not self.GetFoldExpanded(lc): # Select more lines hidden if folded.
             self.CharRightExtend()
             q = self.cpos
             if q == self.TextLength:
                 q -= 1
-        self._anchors = [p, q]
+        self.__anchors = [p, q]
     
     def on_linesel_motion(self, evt): #<wx._core.MouseEvent>
         p = self.PositionFromPoint(evt.Position)
-        po, qo = self._anchors
+        po, qo = self.__anchors
         if p >= po:
             lc = self.LineFromPosition(p)
             text = self.GetLine(lc)
             self.cpos = p + len(text)
             self.anchor = po
             if not self.GetFoldExpanded(lc): # Select more lines hidden if folded.
                 self.CharRightExtend()
-                self._anchors[1] = self.cpos
+                self.__anchors[1] = self.cpos
         else:
             self.cpos = p
             self.anchor = qo
         self.EnsureCaretVisible()
     
     def on_linesel_end(self, evt):
-        del self._anchors
+        del self.__anchors
         if self.HasCapture():
             self.ReleaseMouse()
     
     ## --------------------------------
     ## Preferences / Appearance
     ## --------------------------------
     
@@ -1554,18 +1554,15 @@
         evt.Skip()
     
     def on_activated(self, buf):
         """Called when the buffer is activated."""
         if self.mtdelta is not None and self.mtdelta > 0:
             prefix = '! ' if not buf.IsModified() else '*! '
             self.parent.handler('buffer_caps', self, prefix + self.name)
-            self.message("{!r} has been modified externally."
-                         .format(self.filename))
-        title = "{} file: {}".format(self.parent.Name, self.filename)
-        self.parent.handler('title_window', title)
+            self.message("{!r} has been modified externally.".format(self.filename))
         self.trace_position()
     
     def on_inactivated(self, buf):
         """Called when the buffer is inactivated."""
         pass
     
     def on_enter_escmap(self, evt):
@@ -1751,24 +1748,23 @@
             self.parent.handler(self.handler.event, *v)
         
         self.make_keymap('C-x')
         self.make_keymap('C-c')
         
         self.handler.update({ # DNA<EditorBook>
             None : {
-                   'buffer_new' : [ None, ],
-                  'buffer_caps' : [ None, self.set_caption ],
-                 'buffer_saved' : [ None, self.set_caption ],
-                'buffer_loaded' : [ None, self.set_caption ],
-               'buffer_removed' : [ None, ],
-              'buffer_selected' : [ None, ],
-             'buffer_activated' : [ None, ],
-           'buffer_inactivated' : [ None, ],
-          'buffer_filename_set' : [ None, ],
-                 'title_window' : [ None, dispatch ],
+                   'buffer_new' : [ None, dispatch, ],
+                  'buffer_caps' : [ None, dispatch, self.set_caption ],
+                 'buffer_saved' : [ None, dispatch, self.set_caption ],
+                'buffer_loaded' : [ None, dispatch, self.set_caption ],
+               'buffer_removed' : [ None, dispatch, ],
+              'buffer_selected' : [ None, dispatch, ],
+             'buffer_activated' : [ None, dispatch, self.on_activated ],
+           'buffer_inactivated' : [ None, dispatch, self.on_inactivated ],
+          'buffer_filename_set' : [ None, dispatch, ],
              '*button* pressed' : [ None, dispatch, skip ],
             '*button* released' : [ None, dispatch, skip ],
             },
             0 : { # Normal mode
                     '* pressed' : (0, skip),
                    '* released' : (0, skip),
                  'M-up pressed' : (0, _F(self.previous_buffer)),
@@ -1838,14 +1834,23 @@
         if buf:
             _setattribute(buf, kwargs)
         else:
             self.defaultBufferStyle.update(kwargs)
             for buf in self.all_buffers:
                 _setattribute(buf, self.defaultBufferStyle)
     
+    def on_activated(self, buf):
+        """Called when the buffer is activated."""
+        title = "{} file: {}".format(self.Name, buf.filename)
+        self.parent.handler('title_window', title)
+    
+    def on_inactivated(self, buf):
+        """Called when the buffer is inactivated."""
+        pass
+    
     ## --------------------------------
     ## Buffer list controls
     ## --------------------------------
     
     @property
     def all_buffers(self):
         return [self.GetPage(j) for j in range(self.PageCount)]
@@ -1929,17 +1934,25 @@
     ## --------------------------------
     wildcards = [
         "PY files (*.py)|*.py",
         "ALL files (*.*)|*.*",
     ]
     
     def need_buffer_save_p(self, buf):
-        """Returns whether the buffer should be saved."""
+        """Returns whether the buffer should be saved.
+        The file has been modified internally.
+        """
         return buf.mtdelta is not None and buf.IsModified()
     
+    def need_buffer_load_p(self, buf):
+        """Returns whether the buffer should be loaded.
+        The file has been modified externally.
+        """
+        return buf.mtdelta is not None and buf.mtdelta > 0
+    
     def load_url(self, url, *args, **kwargs):
         import requests
         if wx.MessageBox(
                 "You are loadint URL contents.\n\n"
                f"{url!r}\n"
                 "Continue loading?",
                 "Load URL",
@@ -1950,30 +1963,30 @@
             res = requests.get(url)
         except Exception as e:
             self.post_message("Failed to load URL: {}".format(e))
             return None
         if res.status_code == 200: # success
             buf = self.find_buffer(url) or self.create_buffer(url)
             buf._load_textfile(res.text, url)
-            buf.SetFocus()
+            self.swap_page(buf)
             return True
         return False
     
     def load_cache(self, filename, lineno=0, globals=None):
         """Load a file from cache using linecache.
         Note:
             The filename should be an absolute path.
             The buffer will be reloaded without confirmation.
         """
         linecache.checkcache(filename)
         lines = linecache.getlines(filename, globals)
         if lines:
             buf = self.find_buffer(filename) or self.create_buffer(filename)
             buf._load_textfile(''.join(lines), filename, lineno)
-            buf.SetFocus()
+            self.swap_page(buf)
             return True
         return False
     
     def load_file(self, filename, lineno=0):
         """Load a file into an existing or new buffer.
         """
         buf = self.find_buffer(filename) or self.create_buffer(filename)
@@ -1986,15 +1999,15 @@
                     style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
                 self.post_message("The load has been canceled.")
                 return None
         try:
             self.Freeze()
             org = self.buffer
             if buf._load_file(buf.filename, lineno):
-                buf.SetFocus()
+                self.swap_page(buf)
                 return True
             return False
         except Exception as e:
             self.post_message("Failed to load {!r}: {}".format(buf.name, e))
             self.remove_buffer(buf)
             if org:
                 self.swap_page(org)
@@ -2002,15 +2015,15 @@
         finally:
             self.Thaw()
     
     def save_file(self, filename, buf=None):
         """Save the current buffer to a file.
         """
         buf = buf or self.buffer
-        if buf.mtdelta is not None and buf.mtdelta > 0:
+        if self.need_buffer_load_p(buf):
             self.swap_page(buf)
             if wx.MessageBox(
                     "The file has been modified externally.\n\n"
                     "The contents of the file will be overwritten.\n"
                     "Continue saving?",
                     "Save {!r}".format(buf.name),
                     style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
@@ -2392,18 +2405,18 @@
         def dispatch(v):
             """Fork mouse events to the parent."""
             self.parent.handler(self.handler.event, v)
         
         self.handler.update({ # DNA<Nautilus>
             None : {
                   'stc_updated' : [ None, ],
-                'shell_deleted' : [ None, self.on_deleted ],
-              'shell_activated' : [ None, self.on_activated ],
-            'shell_inactivated' : [ None, self.on_inactivated ],
                  'interp_error' : [ None, self.on_interp_error ],
+                'shell_deleted' : [ None, dispatch, self.on_deleted ],
+              'shell_activated' : [ None, dispatch, self.on_activated ],
+            'shell_inactivated' : [ None, dispatch, self.on_inactivated ],
              '*button* pressed' : [ None, dispatch, skip ],
             '*button* released' : [ None, dispatch, skip ],
             },
             -1 : { # original action of the wx.py.shell
                     '* pressed' : (0, skip, self.on_exit_escmap),
                  '*alt pressed' : (-1, ),
                 '*ctrl pressed' : (-1, ),
```

## mwx/utilus.py

```diff
@@ -312,65 +312,73 @@
 
 
 def _extract_words_from_tokens(tokens, reverse=False):
     """Extracts pythonic expressions from tokens
     until sep is found after the parenthesis is closed.
     
     The default sep includes `@, ops, delims, and whitespaces, etc.
+    Returns:
+        A token list extracted including the parenthesis.
+        If reverse is True, the order of the tokens will be reversed.
     """
     sep = "`@=+-/*%<>&|^~!?,:; \t\r\n#"
     p, q = "({[", ")}]"
     if reverse:
         p, q = q, p
     stack = []
     words = []
     for j, c in enumerate(tokens):
         if c in p:
             stack.append(c)
         elif c in q:
-            if not stack: # error("open-paren", c)
+            if not stack: # error("open-paren")
                 break
-            if c != q[p.index(stack.pop())]: # error("mismatch-paren", c)
+            if c != q[p.index(stack.pop())]: # error("mismatch-paren")
                 break
         elif not stack and c in sep: # ok
             break
         words.append(c)
     else:
         j = None
-        if stack: # error("unclosed-paren", ''.join(stack))
+        if stack: # error("unclosed-paren")
             pass
     del tokens[:j] # remove extracted tokens
-    return words #''.join(reversed(words) if reverse else words)
+    return words
 
 
 def _extract_paren_from_tokens(tokens, reverse=False):
     """Extracts parenthesis from tokens.
     
     The first token must be a parenthesis.
-    If the parenthesis is not closed, returns None.
+    Returns:
+        A token list extracted including the parenthesis,
+        or an empy list if the parenthesis is not closed.
+        If reverse is True, the order of the tokens will be reversed.
     """
     p, q = "({[", ")}]"
     if reverse:
         p, q = q, p
     stack = []
     words = []
     for j, c in enumerate(tokens):
         if c in p:
             stack.append(c)
         elif c in q:
-            if not stack: # error("open-paren", c)
-                return None
-            if c != q[p.index(stack.pop())]: # error("mismatch-paren", c)
-                return None
+            if not stack: # error("open-paren")
+                return []
+            if c != q[p.index(stack.pop())]: # error("mismatch-paren")
+                return []
         elif j == 0:
-            return None # not found
+            return [] # not found
         words.append(c)
         if not stack: # ok
             del tokens[:j+1] # remove extracted tokens
-            return words #''.join(reversed(words) if reverse else words)
+            return words
+    else:
+        return [] # error("unclosed-paren")
 
 
 def find_modules(force=False, verbose=True):
     """Find all modules available and write to log file.
     
     Similar to pydoc.help, it scans packages, but also submodules.
     This creates a log file in ~/.mwxlib and save the list.
@@ -430,26 +438,26 @@
     """
     home = os.path.normpath(os.path.expanduser("~/.mwxlib"))
     if not os.path.exists(home):
         os.mkdir(home)
     return os.path.join(home, f)
 
 
-def deprecated(f=None, version="the future", count=1):
+def deprecated(f=None, count=1):
     if f is None:
-        return lambda f: deprecated(f, version, count)
+        return lambda f: deprecated(f, count)
     @wraps(f)
-    def _f(*args, **kwargs):
+    def _f(*v, **kw):
         nonlocal count
         if count:
             warnings.warn(
-                f"{f.__name__!r} is deprecated and will be removed in {version}.",
+                f"{f.__name__!r} is deprecated and will be removed in the future version",
                 DeprecationWarning, stacklevel=2)
             count -= 1
-        return f(*args, **kwargs)
+        return f(*v, **kw)
     return _f
 
 
 ## --------------------------------
 ## Finite State Machine
 ## --------------------------------
```

## mwx/wxmon.py

```diff
@@ -88,15 +88,16 @@
     
     def OnDestroy(self, evt):
         if evt.EventObject is self:
             self.unwatch()
         evt.Skip()
     
     def OnSetFocus(self, evt):
-        self.parent.handler('title_window', self.__class__.__name__)
+        title = "{} target: {}".format(self.__class__.__name__, self.target)
+        self.parent.handler('title_window', title)
         evt.Skip()
     
     ## --------------------------------
     ## EventWatcher wrapper interface
     ## --------------------------------
     ew.buildWxEventMap() # build ew._eventBinders and ew._eventIdMap
```

## mwx/wxpdb.py

```diff
@@ -292,18 +292,15 @@
     def find_editor(self, f):
         """Find parent editor which has the specified f:object,
         where `f` can be filename or code object.
         """
         for editor in self.parent.get_pages(type(self.editor)):
             buf = editor.find_buffer(f)
             if buf:
-                wnd = wx.Window.FindFocus()
-                buf.SetFocus()
-                if wnd is self.interactive_shell:
-                    wnd.SetFocus()
+                editor.swap_page(buf)
                 return editor
     
     def on_debug_begin(self, frame):
         """Called before set_trace.
         Note: self.busy -> False or None
         """
         shell = self.interactive_shell
```

## mwx/wxwit.py

```diff
@@ -27,15 +27,15 @@
         self.target = None
         
         self.Font = wx.Font(9, wx.DEFAULT, wx.NORMAL, wx.NORMAL)
         self.timer = wx.Timer(self)
         self.toolFrame = self
         
         self._noWatchList = [self,
-                             self.GetTopLevelParent()]
+                             self.TopLevelParent]
         
         self.Bind(wx.EVT_TREE_ITEM_GETTOOLTIP, self.OnItemTooltip)
         self.Bind(wx.EVT_RIGHT_DOWN, self.OnRightDown)
         self.Bind(wx.EVT_SHOW, self.OnShow)
         self.Bind(wx.EVT_TIMER, self.OnTimer)
         self.Bind(wx.EVT_SET_FOCUS, self.OnSetFocus)
         self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy)
@@ -61,15 +61,16 @@
     
     def OnDestroy(self, evt):
         if evt.EventObject is self:
             self.timer.Stop()
         evt.Skip()
     
     def OnSetFocus(self, evt):
-        self.parent.handler('title_window', self.__class__.__name__)
+        title = self.__class__.__name__
+        self.parent.handler('title_window', title)
         evt.Skip()
     
     ## --------------------------------
     ## InspectionTree wrapper interface
     ## --------------------------------
     
     def BuildTree(self, *args, **kwargs):
```

## Comparing `mwxlib-0.82.0.dist-info/LICENSE` & `mwxlib-0.82.4.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `mwxlib-0.82.0.dist-info/METADATA` & `mwxlib-0.82.4.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: mwxlib
-Version: 0.82.0
+Version: 0.82.4
 Summary: A wrapper of matplotlib and wxPython (phoenix)
 Home-page: https://github.com/komoto48g/mwxlib
 Author: Kazuya O'moto <komoto@jeol.co.jp>
 Author-email: komoto@jeol.co.jp
 License: MIT
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3
```

## Comparing `mwxlib-0.82.0.dist-info/RECORD` & `mwxlib-0.82.4.dist-info/RECORD`

 * *Files 23% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 mwx/__init__.py,sha256=132PKNl-qpvV8godY4iAnHcupnmPTWfFx-j7tantnmA,2521
 mwx/controls.py,sha256=TrDrq5ldJe8UcN4_JSoAO95LlFGxFuEIpME5Uea4f-8,43241
-mwx/framework.py,sha256=7KScBW50BDcxGaWtbKk5kNSA3QM3w5E9i_a3bCp021g,72432
-mwx/graphman.py,sha256=7LTz993cz_vpI6D2K9TEcT-f20XDQTTbaSTpziBIy3o,69528
+mwx/framework.py,sha256=IFEctHzx3-ZftUJZWORXtWajbN9r_wxfuM7cO3vHMXs,72345
+mwx/graphman.py,sha256=lxhuFFeDJ8XEOGn_6_IJwWv_DymUsT46aZutfTXHp8E,69266
 mwx/images.py,sha256=9e8X7OpJ6Z3fF3ez17P_qk2D1NMO10-lN8TCtulAqT0,46248
 mwx/matplot2.py,sha256=mzctMUk00m-tvs268PTwdLln7G3NCl6J-5zFzJkfsVI,36004
 mwx/matplot2g.py,sha256=RllnIIgfveFqeFGclNLPWhstAuH1OFWR_l06ifJEq-4,67727
 mwx/matplot2lg.py,sha256=h_aFij_7ksG2DXuYCaGmjtlcl122vZnwbMTv21Mprcg,27606
 mwx/mgplt.py,sha256=49_wpFZUEKErQmtobqrlNKDjWlAsdLft-izlqSyGPD0,6878
-mwx/nutshell.py,sha256=NBKBdIG9li99plvjPiIGgKyAl4juKraUVwwNMEf0p70,137961
-mwx/utilus.py,sha256=FEmdkX9uAn9IngOWvwZeTOvjTa7LRSkUMMlL2aXEuwI,36740
-mwx/wxmon.py,sha256=TeimxBDRFYAf8DsuMnQqof8XHEcjdl8eB1h7Canz5yA,11187
-mwx/wxpdb.py,sha256=Ec504uQ9upQOBlaCQUNN05JAOhTolHIvS_jS7Fg1X04,19793
+mwx/nutshell.py,sha256=xvvPiJ_Cr04UTzrbtQSLE6QwCtUcEViTVjAsxC6G9-g,138522
+mwx/utilus.py,sha256=fuF_0EfVCEkPaAt9lwCBZrMNcngmVCsI0BzSldgKmls,36923
+mwx/wxmon.py,sha256=206qk85IJmjFZwLBaQMJuh6Vw1mMtgwJKRzJidC31jU,11247
+mwx/wxpdb.py,sha256=1fPWkPCB9u9YQnTI-oq9WOs7cgOsLyzur7vFZHWg7Ng,19668
 mwx/wxwil.py,sha256=BUfEF0Nc1E-mVC3Vdz6k1E-2s5J0PO6qEzRQ6lfyePI,5246
-mwx/wxwit.py,sha256=QqV34vmJP06jkv5cRv8oB5ie7enGce3BlDRkNAdlzpg,7398
+mwx/wxwit.py,sha256=-Dy09jCdKHNSbiFCFR3xM92_4PacdSRlPBZcLXIUeVo,7416
 mwx/py/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 mwx/py/filling.py,sha256=f6KMBcBv7gwrl6qmJYLTL-O0Z47bWNAdTCZtUZIo8vM,16794
-mwxlib-0.82.0.dist-info/LICENSE,sha256=PGtRKCaTkmUDlBQwpptJAxJtdqxIUtAmdBsaT9nUVkA,1091
-mwxlib-0.82.0.dist-info/METADATA,sha256=3_vagrNYOJiJ_-4OmK5sco5OdUOwnR31sezxG5uB4CU,1893
-mwxlib-0.82.0.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-mwxlib-0.82.0.dist-info/top_level.txt,sha256=SI1Mh118AstnUFGPNq5aMNKiAnVNmZk1S9Ij-OwAEpY,4
-mwxlib-0.82.0.dist-info/RECORD,,
+mwxlib-0.82.4.dist-info/LICENSE,sha256=PGtRKCaTkmUDlBQwpptJAxJtdqxIUtAmdBsaT9nUVkA,1091
+mwxlib-0.82.4.dist-info/METADATA,sha256=cGHLM6cD8-tp1r4ULD8C-UHnros3DHPJl7aBzJrbn7U,1893
+mwxlib-0.82.4.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+mwxlib-0.82.4.dist-info/top_level.txt,sha256=SI1Mh118AstnUFGPNq5aMNKiAnVNmZk1S9Ij-OwAEpY,4
+mwxlib-0.82.4.dist-info/RECORD,,
```

