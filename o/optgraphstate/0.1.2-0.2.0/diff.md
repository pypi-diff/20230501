# Comparing `tmp/optgraphstate-0.1.2-py3-none-any.whl.zip` & `tmp/optgraphstate-0.2.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,11 +1,11 @@
-Zip file size: 23789 bytes, number of entries: 9
--rw-r--r--  2.0 unx    68529 b- defN 23-Apr-19 10:55 optgraphstate/__init__.py
--rw-r--r--  2.0 unx    14819 b- defN 23-Apr-18 10:28 optgraphstate/graph_tools.py
+Zip file size: 24331 bytes, number of entries: 9
+-rw-r--r--  2.0 unx    69269 b- defN 23-May-01 08:52 optgraphstate/__init__.py
+-rw-r--r--  2.0 unx    15345 b- defN 23-May-01 08:29 optgraphstate/graph_tools.py
 -rw-r--r--  2.0 unx      686 b- defN 23-Apr-06 04:55 optgraphstate/utils.py
 -rw-r--r--  2.0 unx     9075 b- defN 23-Apr-19 10:05 optgraphstate/visualization.py
--rw-r--r--  2.0 unx     1070 b- defN 23-Apr-19 11:31 optgraphstate-0.1.2.dist-info/LICENSE
--rw-r--r--  2.0 unx     1900 b- defN 23-Apr-19 11:31 optgraphstate-0.1.2.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Apr-19 11:31 optgraphstate-0.1.2.dist-info/WHEEL
--rw-r--r--  2.0 unx       14 b- defN 23-Apr-19 11:31 optgraphstate-0.1.2.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx      750 b- defN 23-Apr-19 11:31 optgraphstate-0.1.2.dist-info/RECORD
-9 files, 96935 bytes uncompressed, 22495 bytes compressed:  76.8%
+-rw-r--r--  2.0 unx     1070 b- defN 23-May-01 09:02 optgraphstate-0.2.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     2425 b- defN 23-May-01 09:02 optgraphstate-0.2.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-01 09:02 optgraphstate-0.2.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       14 b- defN 23-May-01 09:02 optgraphstate-0.2.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx      750 b- defN 23-May-01 09:02 optgraphstate-0.2.0.dist-info/RECORD
+9 files, 98726 bytes uncompressed, 23037 bytes compressed:  76.7%
```

## zipnote {}

```diff
@@ -6,23 +6,23 @@
 
 Filename: optgraphstate/utils.py
 Comment: 
 
 Filename: optgraphstate/visualization.py
 Comment: 
 
-Filename: optgraphstate-0.1.2.dist-info/LICENSE
+Filename: optgraphstate-0.2.0.dist-info/LICENSE
 Comment: 
 
-Filename: optgraphstate-0.1.2.dist-info/METADATA
+Filename: optgraphstate-0.2.0.dist-info/METADATA
 Comment: 
 
-Filename: optgraphstate-0.1.2.dist-info/WHEEL
+Filename: optgraphstate-0.2.0.dist-info/WHEEL
 Comment: 
 
-Filename: optgraphstate-0.1.2.dist-info/top_level.txt
+Filename: optgraphstate-0.2.0.dist-info/top_level.txt
 Comment: 
 
-Filename: optgraphstate-0.1.2.dist-info/RECORD
+Filename: optgraphstate-0.2.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## optgraphstate/__init__.py

```diff
@@ -1,12 +1,13 @@
 """
-**Version 0.1.2**
+**Version 0.2.0**
 
 **OptGraphState** is a python package that implements the graph-theoretical
-strategy to optimize the fusion-based generation of any graph state.
+strategy to optimize the fusion-based generation of any graph state, which is
+proposed in [Lee & Jeong, arXiv:2304.11988 [quant-ph] (2023)](https://arxiv.org/abs/2304.11988).
 The package has the following features:
 
 - Finding a resource-efficient method of generating a given graph state through
 type-II fusions from multiple basic resource states, which are three-qubit
 linear graph states.
 - Computing the corresponding resource overhead, which is quantified by the
 average number of required basic resource states or fusion attempts.
@@ -40,24 +41,25 @@
 
 def _max_seed():
     return 2**32
 
 
 class GraphState:
     #: Graph of the graph state to investigate.
+    #: See Sec. 7 of our [tutorial](https://github.com/seokhyung-lee/OptGraphState/raw/main/tutorials.pdf) for the list of its vertex attributes.
     graph: ig.Graph
     #: Unraveled graph generated by unraveling the original graph/
     #:
     #: It is `None` before the unraveled graph is created.
-    #: See Sec. 7 of our tutorial for the list of its vertex attributes.
+    #: See Sec. 7 of our [tutorial](https://github.com/seokhyung-lee/OptGraphState/raw/main/tutorials.pdf) for the list of its vertex attributes.
     unraveled_graph: ig.Graph
     #: Fuson network constructed from the unraveled or original graph.
     #:
     #: It is `None` before the fusion network is created.
-    #: See Sec. 7 of our tutorial for the list of its vertex and edge
+    #: See Sec. 7 of our [tutorial](https://github.com/seokhyung-lee/OptGraphState/raw/main/tutorials.pdf) for the list of its vertex and edge
     #: attributes.
     fusion_network: ig.Graph
     #: Any data obtained during unraveling the graph, constructing the fusion
     #: network, and calculating the resource overhead.
     data: dict
 
     def __init__(self,
@@ -82,15 +84,16 @@
         Parameters
         ----------
         graph : None or igraph.Graph or networkx.Graph (default: None)
             Graph of the concerned graph.
 
             If it is given, `edges`, `shape`, and `prms` are ignored.
 
-            If it is [`networkx.Graph`](https://networkx.org/documentation/stable/reference/classes/graph.html), it is internally converted to [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).
+            If it is `networkx.Graph`, it is internally converted to
+            `igraph.Graph`.
 
         edges : None or list of 2-tuple of int (default: None)
             List of edges that form the concerned graph.
 
             Each integer in the tuples indicates a vertex label.
 
             If it is given and `graph` is `None`, `shape` and `prms` are
@@ -123,20 +126,28 @@
                 `i`th-generation branch.
             - `shape='rhg'` : Raussendorf-Harrington-Goyal lattice with primal
             boundaries only.
                 - `prms[0]`, `prms[1]`, `prms[2]` <`int`> : Size of the lattice
                 along the three axes in the unit of a cell.
             - `shape='repeater'` : Repeater graph with 4m vertices.
                 - `prms[0]` <`int`> : Parameter m.
-            - `shape='parity_encoding'` : (n, m) parity-encoded graph.
-                - `prms[0]` <[`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html)> : Logical-level graph. Can be
+            - `shape='parity_encoding'` : (n, m) parity-encoded graph, where
+            each vertex of the logical graph corresponds to a qubit encoded in
+            the basis of either {(|0>^m + |1>^m)^n +- (|0>^m - |1>^m)^n}
+            (Orientation 1) or {[(|0> + |1>)^m +- (|0> - |1>)^m]^n}
+            (Orientation 2).
+                - `prms[0]` <`igraph.Graph`> : Logical-level graph. Can be
                 generated with python-igraph library directly or from the
-                function `get_graph_from_edges()` or `get_sample_graph`.
+                function `optgraphstate.graph_tools.get_graph_from_edges()` or
+                `optgraphstate.graph_tools.get_sample_graph()`.
                 - `prms[1]`, `prms[2]` <`int`> : Parameters n and m of the
                 parity encoding.
+                - [Optional] `prms[3]` <`bool`> : Orientation of the parity
+                encoding. If `True` (default), "Orientation 1" is used. If
+                `False`, "Orientation 2" is used.
             - `shape='ptqc'` : Microcluster for parity-encoding-based
             topological quantum computing protocol.
                 - `prms[0]`, `prms[1]` <`int`> : Parameter n and m of the
                 parity encoding.
                 - `prms[2]` <`bool`> : Whether the H-configuration is
                 HIC (`True`) or HIS (`False`).
                 - `prms[3]` <`bool`> : Whether the microcluster is
```

## optgraphstate/graph_tools.py

```diff
@@ -87,15 +87,15 @@
         vcount = g.vcount()
         for v in range(vcount):
             new_v = g.add_vertex()
             g.add_edge(v, new_v)
         # g['m'] = prms[0]
 
     elif shape == 'parity_encoding':
-        assert len(prms) == 3
+        assert len(prms) in [3, 4]
         g = _get_parity_encoded_graph(*prms)
         # g['logical_graph'] = prms[0]
         # g['n'] = prms[1]
         # g['m'] = prms[2]
 
     elif shape == 'ptqc':
         assert len(prms) == 4
@@ -428,43 +428,60 @@
     else:
         _connect_vertex_sets(graph, vids_lqs[0], vids_lqs[1])
         _connect_vertex_sets(graph, vids_lqs[1], vids_lqs[2])
 
     return graph
 
 
-def _get_parity_encoded_graph(logical_graph: ig.Graph, n, m):
+def _get_parity_encoded_graph(logical_graph: ig.Graph, n, m, orientation=True):
     logical_vcount = logical_graph.vcount()
     vcount = logical_vcount * n * m
     g = ig.Graph(vcount, vertex_attrs={"clifford": None})
 
     # Internal structure of each logical qubit
-    for first_vid in range(0, vcount, n * m):
-        # The first block is connected with the first vertex of each block.
-        vids_first_block = range(first_vid, first_vid + m)
-        first_vids_each_block = range(first_vid + m, first_vid + n * m, m)
-        _connect_vertex_sets(g, vids_first_block, first_vids_each_block)
-
-        # For each block besides the first one, the first vertex is
-        # connected with the other vertices.
-        for first_vid_each_block in range(first_vid + m, first_vid + n * m, m):
-            other_vids = range(first_vid_each_block + 1,
-                               first_vid_each_block + m)
-            _connect_vertex_sets(g, [first_vid_each_block], other_vids)
+    for vid_1_1 in range(0, vcount, n * m):
 
-        # The first vertex of each block has the Hadamard gate.
-        g.vs[first_vids_each_block]['clifford'] = 'H'
+        # |0_L(1_L)> = (|0>^m + |1>^m)^n \pm (|0>^m - |1>^m)^n
+        if orientation:
+            vids_1_all = range(vid_1_1, vid_1_1 + m)
+            vids_not1_1 = range(vid_1_1 + m, vid_1_1 + n * m, m)
+            # The first block is connected with the first vertex of each block.
+            _connect_vertex_sets(g, vids_1_all, vids_not1_1)
+
+            # For each block besides the first one, the first vertex is
+            # connected with the other vertices.
+            for vid_x_1 in vids_not1_1:
+                vids_x_not1 = range(vid_x_1 + 1, vid_x_1 + m)
+                _connect_vertex_sets(g, [vid_x_1], vids_x_not1)
+
+            # The first vertex of each block has the Hadamard gate.
+            g.vs[vids_not1_1]['clifford'] = 'H'
+
+        # |0_L(1_L)> = (|+>^m + |->^m)^n
+        else:
+            vids_all_1 = range(vid_1_1, vid_1_1 + n * m, m)
+            for vid_x_1 in vids_all_1:
+                vids_x_not1 = range(vid_x_1 + 1, vid_x_1 + m)
+                _connect_vertex_sets(g, [vid_x_1], vids_x_not1)
+                g.vs[vids_x_not1]['clifford'] = 'H'
 
     # Connection between logical qubits
     for logical_edge in logical_graph.es:
         logical_vids = logical_edge.source, logical_edge.target
-        vids_first_blocks = [
-            range(logical_vid * n * m, logical_vid * n * m + m) for logical_vid
-            in logical_vids]
-        _connect_vertex_sets(g, *vids_first_blocks)
+        physical_vids = []
+        for logical_vid in logical_vids:
+            vid_1_1 = logical_vid * n * m
+            if orientation:
+                physical_vids_sng = range(vid_1_1, vid_1_1 + m)
+
+            else:
+                physical_vids_sng = range(vid_1_1, vid_1_1 + n * m, m)
+            physical_vids.append(physical_vids_sng)
+
+        _connect_vertex_sets(g, *physical_vids)
 
     return g
 
 
 def _get_rhg_lattice(Lx, Ly, Lz):
     g = ig.Graph()
     size = (2 * Lx, 2 * Ly, 2 * Lz)
```

## Comparing `optgraphstate-0.1.2.dist-info/LICENSE` & `optgraphstate-0.2.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `optgraphstate-0.1.2.dist-info/METADATA` & `optgraphstate-0.2.0.dist-info/METADATA`

 * *Files 21% similar despite different names*

```diff
@@ -1,30 +1,33 @@
 Metadata-Version: 2.1
 Name: optgraphstate
-Version: 0.1.2
+Version: 0.2.0
 Summary: Graph-theoretical optimization of fusion-based graph state generation
 Home-page: https://github.com/seokhyung-lee/OptGraphState
 Author: Seok-Hyung Lee
 Author-email: sh.lee1524@gmail.com
 License: UNKNOWN
 Platform: UNKNOWN
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
 Description-Content-Type: text/markdown
 License-File: LICENSE
 
 # OptGraphState
 
-**Version 0.1.2**
+**Version 0.2.0**
 
 *Graph-theoretical optimization of fusion-based graph state generation.*
 
 **OptGraphState** is a python package that implements the graph-theoretical strategy to optimize the fusion-based
-generation of any graph state. The package has the following features:
+generation of any graph state, which is proposed
+in [Lee & Jeong, arXiv:2304.11988 [quant-ph] (2023)](https://arxiv.org/abs/2304.11988).
+
+The package has the following features:
 
 - Finding a resource-efficient method of generating a given graph state through type-II fusions from multiple basic
   resource states, which are three-qubit linear graph states.
 - Computing the corresponding resource overhead, which is quantified by the average number of required basic resource
   states or fusion attempts.
 - Visualizing the original graph (of the graph state you want to generate), unraveled graphs, and fusion networks. An
   unraveled graph is a simplified graph where the corresponding graph state is equivalent to the desired graph state up
@@ -42,8 +45,23 @@
 
 API reference: https://seokhyung-lee.github.io/OptGraphState
 
 ## License
 
 OptGraphState is distributed under the MIT license. Please see the LICENSE file for more details.
 
+## Citation
+
+If you want to cite OptGraphState in an academic work, please cite the arXiv preprint:
+
+```
+@misc{lee2023graph,
+      title={Graph-theoretical optimization of fusion-based graph state generation}, 
+      author={Seok-Hyung Lee and Hyunseok Jeong},
+      year={2023},
+      eprint={2304.11988},
+      archivePrefix={arXiv},
+      primaryClass={quant-ph},
+      url={https://arxiv.org/abs/2304.11988}
+}
+```
```

## Comparing `optgraphstate-0.1.2.dist-info/RECORD` & `optgraphstate-0.2.0.dist-info/RECORD`

 * *Files 26% similar despite different names*

```diff
@@ -1,9 +1,9 @@
-optgraphstate/__init__.py,sha256=el-mtgl_TeJ3JiBpGU69jWpGEbDPvIt3lWEqLPRjCr4,68529
-optgraphstate/graph_tools.py,sha256=foGOoB5jUwToLVSP5iuhn00fk-uokV_cZVdrWWR3uy8,14819
+optgraphstate/__init__.py,sha256=HR-doWIXkkx97TgWR9hgLujwqLFxSMNfN1N4CK7_FS4,69269
+optgraphstate/graph_tools.py,sha256=31DxDyfnQcRmQq76mOsjwN9rWZPZ4sGHdlirbB3G124,15345
 optgraphstate/utils.py,sha256=11ak92ZwuPQl6DVVEI45mS_gjS-QKZONObwuRvRpmpE,686
 optgraphstate/visualization.py,sha256=uqadIHvlo201dImbcp93di5QVJN4na9IyyTV3gCqtXs,9075
-optgraphstate-0.1.2.dist-info/LICENSE,sha256=rB8sqYvzli01OnnAHmeXktkq7ye_YYJjOWP25yuN8VY,1070
-optgraphstate-0.1.2.dist-info/METADATA,sha256=H87KTajmcKjbt4Hum7wxXCzYLKbxpDYGPPKblYBsMHs,1900
-optgraphstate-0.1.2.dist-info/WHEEL,sha256=ewwEueio1C2XeHTvT17n8dZUJgOvyCWCt0WVNLClP9o,92
-optgraphstate-0.1.2.dist-info/top_level.txt,sha256=Rj9Sk6j_-PrVy4Gk6bDHLQEpm37egogxHKxd9xLk0A0,14
-optgraphstate-0.1.2.dist-info/RECORD,,
+optgraphstate-0.2.0.dist-info/LICENSE,sha256=rB8sqYvzli01OnnAHmeXktkq7ye_YYJjOWP25yuN8VY,1070
+optgraphstate-0.2.0.dist-info/METADATA,sha256=FZZxjg-hkfQ9SoCI3Cp1AUw4t44Nn6-6hpjZE7wUW64,2425
+optgraphstate-0.2.0.dist-info/WHEEL,sha256=ewwEueio1C2XeHTvT17n8dZUJgOvyCWCt0WVNLClP9o,92
+optgraphstate-0.2.0.dist-info/top_level.txt,sha256=Rj9Sk6j_-PrVy4Gk6bDHLQEpm37egogxHKxd9xLk0A0,14
+optgraphstate-0.2.0.dist-info/RECORD,,
```

